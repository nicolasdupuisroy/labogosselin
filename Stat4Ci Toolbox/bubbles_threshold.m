function [peak, extent]=bubbles_threshold(resels,bubres,pC,Ppeak,Pcluster,Pextent);% Bubbles_threshold finds thresholds or pvalues for peaks in bubbles Z images% using the saddle-point method of Rabinowitz and Siegmund (1997), Statistica% Sinica, 7:167-180. Usage:%% [thresh, extent] = bubbles_threshold(resels,bubres,pC,Ppeak,Pcluster,Pextent)%% resels = #pixels/fwhm^2, either a single number, in which case % the search region is assumed to be a square, or a vector of three % components giving the resels: [ 1  perimeter/2/fwhm  area/fwhm^2 ].% Default is [1 0 0] i.e. just a single point.%% bubres is the total number of bubbles per resel, i.e. #bubles per image x % #images / #resels . Default is Inf, which gives Gaussian results.%% pC is the proportion of correct responses in the contrast of the images. % If pC is a vector it is the contrast values for each bubble image, e.g.% 1/#correct repeated #correct times, then -1/#incorrect repeated #incorrect % times, which is the same as the scalar pC=#correct/(#correct+#incorrect).% Note that if pC is a vector, multplying all elements by a factor or doub-% ling its length gives the same results, but the elements should sum to 0. % Default is 0.5. %% Ppeak is a vector of P-values for peaks. If the first component is >1 then% they are treated as peaks and 'peak' resturns the pvalue. Default is 0.05. %% Pcluster is a P-value for the cluster threhold. If it is >1% then it is treated as the actual threshold. Default is 0.001. %% Pextent is a vector of P-values for extents. If the first component % is >1 then they are treated as extents (in resels) and 'extent' resturns % the pvalue. Default is 0.05. %% peak is the threshold for peaks. %% extent is the threshold for extents, in resels. if nargin<1; resels=[1 0 0]; endif nargin<2; bubres=Inf; endif nargin<3; pC=0.5; endif nargin<4; Ppeak=0.05; endif nargin<5; Pcluster=0.001; endif nargin<6; Pextent=0.05; endif length(resels)==1   Resels=[1 2*sqrt(resels) resels];else   Resels=resels;enddz=0.01;z=10:-dz:-10;nz=length(z);theta=z;if bubres==Inf   I=z.^2/2;   cdot=1;   c2=1;else   % cumulants:   nk=20;   D=2;   j=1:nk;   if length(pC)==1      mu=pC.^(1-j)+(-1).^j.*(1-pC).^(1-j);   else      mu=zeros(1,nk);      for jj=1:nk         mu(jj)=mean(pC.^jj);      end   end   kappa=mu./mu(2).^(j/2).*2.^(D*j/4)./j.^(D/2)./((pi/4/log(2))^(D/2)*bubres).^(j/2-1);   % saddle point approximation:   niter=5;   for iter=1:niter      c1=zeros(1,nz);      c2=ones(1,nz);      thetaj=ones(1,nz);      for j=1:nk         thetaj=thetaj.*theta/j;          if (j+1)<=nk; c1=c1+kappa(j+1).*thetaj; end;         if (j+2)<=nk; c2=c2+kappa(j+2).*thetaj; end;      end      theta=theta-(c1-z)./c2;   end   c0=zeros(1,nz);   cdot=ones(1,nz);   thetaj=ones(1,nz);   for j=1:nk      thetaj=thetaj.*theta/j;       if j>=2; c0=c0+kappa(j).*thetaj; end;      if (j+2)<=nk; cdot=cdot+kappa(j+2).*thetaj/(j/2+1); end;   end   I=theta.*c1-c0;endp=exp(-I)./sqrt(2*pi*c2)*dz;% Find upper tails by Simpson's rulesp=cumsum(p);sp1=cumsum(p.*(-1).^(1:nz));p1=sp+sp1/3-p/3;p2=sp-sp1/3-p/3;P=zeros(1,nz);P(1:2:nz)=p1(1:2:nz);P(2:2:nz)=p2(2:2:nz);% peaksec1=sqrt(4*log(2)*cdot).*exp(-I)/(2*pi)./sqrt(c2);ec2=4*log(2)*cdot.*theta.*exp(-I)/(2*pi)^(3/2)./sqrt(c2);ps=Resels(1)*P+Resels(2)*ec1+Resels(3)*ec2;if Ppeak(1)<1   peak=minterp1(ps,z,Ppeak);else   peak=interp1(z,ps,Ppeak);end% extentsif Pcluster<1   thresh=minterp1(P,z,Pcluster)   PV=Pcluster;else   thresh=Pcluster;   PV=interp1(z,P,thresh);endNV=interp1(z,ec2,thresh);EV=PV/NV;if Pextent(1)<1   extent=-log(-log(1-Pextent)/(Resels(3)*NV))*EV;else   extent=1-exp(-Resels(3)*NV*exp(-Pextent/EV));endreturnfunction iy=minterp1(x,y,ix);% interpolates only the monotonically increasing values of x at ixn=length(x);mx=x(1);my=y(1);xx=x(1);for i=2:n   if x(i)>xx      xx=x(i);      mx=[mx xx];      my=[my y(i)];   endendiy=interp1(mx,my,ix);return