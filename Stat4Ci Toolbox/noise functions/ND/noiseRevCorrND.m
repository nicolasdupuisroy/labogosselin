function varargout = noiseRevCorrND(varargin);% bruit_filtre = noiseFreqAdditive(xSize,ySize,snr,noiseFunction, profile)% Fred Gosselin, 05/02/03 and Alan Chauvin 01/07/05% ------------------------------------------------------------------------% -- 0.0 global and local variables initializationglobal glopar;if ((length(glopar) < 4) | (length(glopar) > 6) )	s1 = sprintf('glopar{1}{1..D} = size along the D axis\nglopar(2) = signal-to-noise ratio\nglopar(3) the pdf to be chosen (e.g. gauss, unif, sparse) \n');	s2 = sprintf('glopar(4) = proportion of active pixel (default = 1)\nglopar(5) = a vector, the filter profile \nMust be defined in the CID.\nglopar{6} = information about the stimulus: bits, min and max\n');	error([s1,s2]);end% global variable% estimate and initialize the number of dimensiondimNumber =  max(size(glopar{1}));xSize = glopar{1};if dimNumber == 1;	xSize = [1,xSize];end;	noiseControl = glopar{2};noiseFunction = glopar{3};prop = glopar{4};if length(glopar) < 5,	mixFunction = 'add';else,					mixFunction = glopar{5};end;% inputoneTrial = varargin{1};if sum(eq(xSize(1),xSize)) ~= length(xSize),	error('the images must be squared');end;	% ------------------------------------------------------------------------% -- 1.0 generate the noiseswitch noiseFunctioncase 'gaussian'	randn('state',  oneTrial(1));	theNoise = randn(xSize) .* round(rand(xSize)-(.5-prop));	muTheNoise = 0;case 'uniform'	% pour la proportion du gaussien voir avec sigma	rand('state', oneTrial(1));	theNoise = rand(xSize) .* round(rand(xSize)-(.5-prop));	muTheNoise = 0.5 * prop;otherwise	error('the noise generating function is not specified')end;if nargin == 1	varargout{1} = theNoise;	return;end;% ------------------------------------------------------------------------% -- 2.0 mix the noise with an imageanImage = double(varargin{2});anImage = (anImage - min(anImage(:))) / (max(anImage(:)) - min(anImage(:)));switch mixFunctioncase 'add'	theStimulus = noiseControl * (anImage - .5) + (1 - noiseControl) * (theNoise - muTheNoise) + .5;case 'mult'		theStimulus =  noiseControl * anImage .* theNoise;case 'speckle'	theStimulus = anImage + sqrt(12*noiseControl) * anImage .* theNoise; % varNoise = 0.04end;mmin = min(theStimulus(:));mmax = max(theStimulus(:)); % we suppose that (1) images are scaled beetween 0 and 1 and (2) we used 256 gray level, i.e. max bits = 8bits = log2(floor((mmax-mmin)*256));glopar{6}(1) = bits;glopar{6}(2) = mmin;glopar{6}(3) = mmax;varargout{1} = theStimulus;