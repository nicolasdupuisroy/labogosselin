function varargout = noiseFrequencyTime(varargin);% ------------------------------------------------------------------------% -- 0.0 global and local variables initializationglobal glopar;if ((length(glopar) < 5 | length(glopar) > 7))	s1 = sprintf('glopar{1}[x, y, t] = size along the x, y and time axis\nglopar{2} = [std_frequency and std_time]\n');	s2 = sprintf('glopar{3} the pdf to be chosen (e.g. gaussian or uniform)\nglopar{4} proportion of active pixel  (1 = all pixels active)\nglopar{5} surface under the filter\n');	s3 = sprintf('glopar{6} for padding (reflect, repeat and constant (i.e must define ''K=0 or mean(anImage(:)) ''))\nMust be defined in the CID.\nglopar{7} = information about the stimulus: bits, min and max\n');	error([s1,s2,s3]);end% global variablexSize = glopar{1}(1);ySize = glopar{1}(2);tSize = glopar{1}(3);stdFreq =  glopar{2}(1);stdTime =  glopar{2}(2);noiseFunction = glopar{3}prop =  glopar{4};surface = glopar{5};if size(glopar)<6	padding = 'zero';else	padding = glopar{6};end;% inputoneTrial = varargin{1};% ------------------------------------------------------------------------% -- 1.0 make bubbles% 1.1 set bubble positionsswitch noiseFunctioncase 'gaussian'	randn('state', oneTrial(1));	rand('state', oneTrial(1));	for cptTmp = 1 : tSize 		% 		theNoise(cptTmp,1:xSize/2) = randn(1, xSize/2) .* round(rand(1,xSize/2)-(.5-prop));		theNoise(cptTmp,1:xSize) = randn(1, xSize) .* round(rand(1,xSize)-(.5-prop));		theNoise(cptTmp,xSize/2+1:xSize) = zeros(1,xSize/2);	end;case 'uniform'	rand('state', oneTrial(1));	for cptTmp = 1 : tSize 		% 		theNoise(cptTmp,1:xSize/2) = rand(1, xSize/2) .* round(rand(1,xSize/2)-(.5-prop));		theNoise(cptTmp,1:xSize) = rand(1, xSize) .* round(rand(1,xSize)-(.5-prop));		theNoise(cptTmp,xSize/2+1:xSize) = zeros(1,xSize/2);	end;otherwise	error('the noise generating function is not specified')end;if nargin == 1	varargout{1} = theNoise;	return;end;% 1.2 one bubblestdFreq = stdFreq/sqrt(log(2));	% cut at 0.5stdTime = stdTime/sqrt(log(2));		% cut at 0.5[x, t] = meshgrid(-xSize:xSize-1,-tSize:tSize-1);oneBubble = (1/(2*pi*stdFreq*stdTime))*exp(-( (x/stdFreq).^2 + (t/stdTime).^2)/2);fftOneBubble = fft2(oneBubble);bubblesCenterSym = [fliplr(theNoise),theNoise];bubblesCenterSym = [zeros(tSize/2,2*xSize);bubblesCenterSym;zeros(tSize/2,2*xSize)];bubblesCenterSym = real(ifftshift(ifft2( fft2(bubblesCenterSym) .* fftOneBubble )));% ------------------------------------------------------------------------% -- 2.0 Images preprocessing% 2.1 scale image between 0 and 1% anImage = ( anImage - min(anImage(:)) ) ./ ( max(anImage(:)) - min(anImage(:)) );anImage = varargin{2};% 2.2 image padding paddedImage = ones(xSize*2,ySize*2);switch paddingcase 'reflect'	paddedImage(1:xSize/2,1:xSize/2) = fliplr(flipud(anImage(1:xSize/2,1:xSize/2)));	paddedImage(xSize/2+1:3*xSize/2,1:xSize/2) = fliplr(anImage(:,1:xSize/2));	paddedImage(3*xSize/2+1:2*xSize,1:xSize/2) = fliplr(flipud(anImage(xSize/2+1:xSize,1:xSize/2)));	paddedImage(1:xSize/2,3*xSize/2+1:2*xSize) = fliplr(flipud(anImage(1:xSize/2,xSize/2+1:xSize)));	paddedImage(xSize/2+1:3*xSize/2,3*xSize/2+1:2*xSize) = fliplr(anImage(:,xSize/2+1:xSize));	paddedImage(3*xSize/2+1:2*xSize,3*xSize/2+1:2*xSize) = fliplr(flipud(anImage(xSize/2+1:xSize,xSize/2+1:xSize)));	paddedImage(1:xSize/2,xSize/2+1:3*xSize/2) = flipud(anImage(1:xSize/2,:));	paddedImage(3*xSize/2+1:2*xSize,xSize/2+1:3*xSize/2) = flipud(anImage(xSize/2+1:xSize,:));	%paddedImage(xSize/2:xSize*6/4 -1, xSize/2:xSize*6/4-1) = anImage;case 'repeat'	paddedImage(1:xSize/2,1:xSize/2) = anImage(xSize/2+1:xSize,xSize/2+1:xSize);	paddedImage(xSize/2+1:3*xSize/2,1:xSize/2) = anImage(:,xSize/2+1:xSize);	paddedImage(3*xSize/2+1:2*xSize,1:xSize/2) = anImage(1:xSize/2,xSize/2+1:xSize);	paddedImage(1:xSize/2,3*xSize/2+1:2*xSize) = anImage(xSize/2+1:xSize,1:xSize/2);	paddedImage(xSize/2+1:3*xSize/2,3*xSize/2+1:2*xSize) = anImage(:,1:xSize/2);	paddedImage(3*xSize/2+1:2*xSize,3*xSize/2+1:2*xSize) = anImage(1:xSize/2,1:xSize/2);	paddedImage(1:xSize/2,xSize/2+1:3*xSize/2) = anImage(xSize/2+1:xSize,:);	paddedImage(3*xSize/2+1:2*xSize,xSize/2+1:3*xSize/2) = anImage(1:xSize/2,:);otherwise	eval(padding)	paddedImage = paddedImage * K;	% la couleur du padding est celle du fond end;paddedImage(xSize/2+1:xSize*3/2,ySize/2+1:ySize*3/2) = anImage;% centre l'image avant filtragepaddedImage = paddedImage - mean(paddedImage(:));image_f = fft2(paddedImage);% ------------------------------------------------------------------------% -- 2.0 build filter% 2.1  Frequency tab[x, y] = meshgrid(-xSize:xSize-1,-xSize:xSize-1);rayon = sqrt(x .^2 + y .^2);rayon((rayon > (xSize))) = xSize+1;    % tout ce qui est est superieur a xSize (freq max est mis a xSize+1)rayon = max(rayon,1);% 2.2  normalizationbubblesCenterSym = bubblesCenterSym / sum(sum(bubblesCenterSym(:,xSize:2*xSize-1))) * surface *	tSize;	cpt = 0;for cptFrames = tSize/2+1 : 3*tSize/2	cpt = cpt + 1;              		profileFred = [bubblesCenterSym(cptFrames,xSize:2*xSize-1),0];		% 2.3 profil to 2D spectrum	profil2D = profileFred(round(rayon));							% -- 3.0 filter image	stimuli_f_filt = real(ifft2(image_f .* fftshift(profil2D) )) +.5 ;	stimulus(:,:,cpt) = stimuli_f_filt(xSize /2+1:xSize*6/4, ySize/2+1:ySize*6/4);	end% ------------------------------------------------------------------------% -- 3.0 Output and infornation on the stimulusmmin = min(stimulus(:));mmax = max(stimulus(:)); % we suppose that (1) images are scaled beetween 0 and 1 and (2) we used 256 gray level, i.e. max bits = 8bits = log2(floor((mmax-mmin)*256));glopar{7}(1) = bits;glopar{7}(2) = mmin;glopar{7}(3) = mmax;varargout{1} = stimulus;