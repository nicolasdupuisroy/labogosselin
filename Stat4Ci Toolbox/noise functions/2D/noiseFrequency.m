function varargout = NoiseFrequency(varargin);% ------------------------------------------------------------------------% -- 0.0 global and local variables initializationglobal glopar;if ((length(glopar) < 5 | length(glopar) > 8))	s1 = sprintf('glopar{1}[x, y] = size along the x and y axis\nglopar{2} = std_frequency\nglopar(3) the pdf to be chosen (e.g. gaussian or uniform)\n');	s2 = sprintf('glopar{4} = proportion of active pixel (1 = all pixels active)\nglopar{5} surface under the filter\n');	s3 = printf('glopar{6} for padding (reflect, repeat and constant (i.e must define ''K=0 or mean(anImage(:)) ''))\nMust be defined in the CID.\n');	s4 = printf('glopar{7} = information about the stimulus: bits, min and max\n');	error([s1,s2,s3,s4]);end% global variablexSize = glopar{1}(1);ySize = glopar{1}(2);stdFreq = glopar{2};noiseFunction = glopar{3}prop =  glopar{4};surface = glopar{5};if size(glopar)<6	padding = 'zero';else	padding = glopar{6};end;% inputoneTrial = varargin{1};% ------------------------------------------------------------------------% -- 1.0 make bubbles% 1.1 set bubble positionsswitch noiseFunctioncase 'gaussian'	randn('state', oneTrial(1));	rand('state', oneTrial(1));	theNoise(1,1:xSize) = randn(1, xSize) .* round(rand(1,xSize)-(.5-prop));case 'uniform'	rand('state', oneTrial(1));	theNoise(1,1:xSize) = rand(1, xSize) .* round(rand(1,xSize)-(.5-prop));otherwise	error('the noise generating function is not specified')end;theNoise(1,xSize/2+1:xSize) = zeros(1,xSize/2);if nargin == 1	varargout{1} = theNoise;	return;end;% 1.2 one bubblestdFreq = stdFreq/sqrt(log(2));		% cut at 0.5x = [-xSize:xSize-1];oneBubble = (1/(2*pi*stdFreq))*exp(- (x/stdFreq).^2 /2);fftOneBubble = fft(oneBubble);% 1.3 build filterbubblesCenterSym = [fliplr(theNoise),theNoise];bubblesCenterSym = real(ifftshift(ifft( fft(bubblesCenterSym) .* fftOneBubble )));% ------------------------------------------------------------------------% -- 2.0 Images preprocessing% 2.1 scale image between 0 and 1% anImage = ( anImage - min(anImage(:)) ) ./ ( max(anImage(:)) - min(anImage(:)) );anImage = varargin{2};% 2.2 image padding paddedImage = ones(xSize*2,ySize*2);switch paddingcase 'reflect'	paddedImage(1:xSize/2,1:xSize/2) = fliplr(flipud(anImage(1:xSize/2,1:xSize/2)));	paddedImage(xSize/2+1:3*xSize/2,1:xSize/2) = fliplr(anImage(:,1:xSize/2));	paddedImage(3*xSize/2+1:2*xSize,1:xSize/2) = fliplr(flipud(anImage(xSize/2+1:xSize,1:xSize/2)));	paddedImage(1:xSize/2,3*xSize/2+1:2*xSize) = fliplr(flipud(anImage(1:xSize/2,xSize/2+1:xSize)));	paddedImage(xSize/2+1:3*xSize/2,3*xSize/2+1:2*xSize) = fliplr(anImage(:,xSize/2+1:xSize));	paddedImage(3*xSize/2+1:2*xSize,3*xSize/2+1:2*xSize) = fliplr(flipud(anImage(xSize/2+1:xSize,xSize/2+1:xSize)));	paddedImage(1:xSize/2,xSize/2+1:3*xSize/2) = flipud(anImage(1:xSize/2,:));	paddedImage(3*xSize/2+1:2*xSize,xSize/2+1:3*xSize/2) = flipud(anImage(xSize/2+1:xSize,:));	%paddedImage(xSize/2:xSize*6/4 -1, xSize/2:xSize*6/4-1) = anImage;case 'repeat'	paddedImage(1:xSize/2,1:xSize/2) = anImage(xSize/2+1:xSize,xSize/2+1:xSize);	paddedImage(xSize/2+1:3*xSize/2,1:xSize/2) = anImage(:,xSize/2+1:xSize);	paddedImage(3*xSize/2+1:2*xSize,1:xSize/2) = anImage(1:xSize/2,xSize/2+1:xSize);	paddedImage(1:xSize/2,3*xSize/2+1:2*xSize) = anImage(xSize/2+1:xSize,1:xSize/2);	paddedImage(xSize/2+1:3*xSize/2,3*xSize/2+1:2*xSize) = anImage(:,1:xSize/2);	paddedImage(3*xSize/2+1:2*xSize,3*xSize/2+1:2*xSize) = anImage(1:xSize/2,1:xSize/2);	paddedImage(1:xSize/2,xSize/2+1:3*xSize/2) = anImage(xSize/2+1:xSize,:);	paddedImage(3*xSize/2+1:2*xSize,xSize/2+1:3*xSize/2) = anImage(1:xSize/2,:);otherwise	eval(padding)	paddedImage = paddedImage * K;	% la couleur du padding est celle du fond end;paddedImage(xSize/2+1:xSize*3/2,ySize/2+1:ySize*3/2) = anImage;% centre l'image avant filtragepaddedImage = paddedImage - mean(paddedImage(:));image_f = fft2(paddedImage);% ------------------------------------------------------------------------% -- 3.0 build filter% 3.1  Frequency tab[x, y] = meshgrid(-xSize:xSize-1,-xSize:xSize-1);rayon = sqrt(x .^2 + y .^2);rayon((rayon > (xSize))) = xSize+1;    % tout ce qui est est superieur a xSize (freq max est mis a xSize+1)rayon = max(rayon,1);profileFred = [bubblesCenterSym(xSize:2*xSize-1),0];	% pourquoi pas xSize+1:2*xSize ... ou est l'origine ??????% 3.2  normalizationprofileFred = profileFred / sum(profileFred(:)) * surface;	profil2D = profileFred(round(rayon));					% ------------------------------------------------------------------------% -- 4.0 filter imagestimuli_f_filt = real(ifft2(image_f .* fftshift(profil2D) )) +.5 ;stimulus = stimuli_f_filt(xSize /2+1:xSize*6/4, xSize/2+1:xSize*6/4);	% ------------------------------------------------------------------------% -- 5.0 Output and infornation on the stimulusmmin = min(stimulus(:));mmax = max(stimulus(:)); % we suppose that (1) images are scaled beetween 0 and 1 and (2) we used 256 gray level, i.e. max bits = 8bits = log2(floor((mmax-mmin)*256));glopar{7}(1) = bits;glopar{7}(2) = mmin;glopar{7}(3) = mmax;varargout{1} = stimulus;