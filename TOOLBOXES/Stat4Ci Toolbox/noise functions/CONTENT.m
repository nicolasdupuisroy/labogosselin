% proportion bruit gaussientheNoise = randn(xSize) .* round(rand(xSize)-(.5-prop));fonction 2Dfunction varargout = noiseWhite(varargin)'glopar(1) = size along the X axis\nglopar(2) = size along the Y axis\nglopar(3) = signal-to-noise ratio\nMust be defined in the CID.'));function varargout=noisePyramid(varargin)error(sprintf('glopar{1} = size along the X axis\nglopar{2} = size along the Y axis\nglopar{3} = std of one bubble in minimum number of cycles\nglopar{4} = a vector of 5 numbers of bubbles\nMust be defined in the CID.'));function varargout=noiseLocation(varargin)error(sprintf('glopar{1} = size along the X axis\nglopar{2} = size along the Y axis\nglopar{3} = std of one bubble\nglopar{4} = number of bubbles\nMust be defined in the CID.'));function varargout = NoiseFrequency(varargin);s1 = sprintf('glopar{1}[1, 2] = size along the 2 axis\nglopar(2) = frequency std\nglopar(3) the pdf to be chosen (e.g. gaussian or uniform)\n');s2 = sprintf('glopar(4) glopar(4) = proportion of active pixel (default = 1) \nglopar(5) surface under the filter \nglopar(6) optional for padding (reflect, zero and mean) \n');s3 = sprintf('glopar(7) bits, min and max \nMust be defined in the CID.');function varargout = noiseFrequencyTime(varargin);s1 = sprintf('glopar{1}[1, 2] = size along the 2 axis\nglopar(2) = size along the time axis \nglopar(3) = frequency and time std\n');s2 = sprintf('glopar(4) the pdf to be chosen (e.g. gaussian or uniform)\nglopar(5) proportion of active pixel (default = 1)\nglopar(6) surface under the filter\n');s3 = sprintf('glopar(7) for padding (reflect, zero and mean)\n glopar(8) bits, min and max \nMust be defined in the CID.\n');function varargout = noiseFreqAdd(varargin);s1 = sprintf('glopar(1) = size along the X axis\nglopar(2) = size along the Y axis\nglopar(3) = signal-to-noise ratio \n');s2 = sprintf('glopar(4) the pdf to be chosen (e.g. gauss, unif, sparse) \nglopar(5) = a vector, the filter profile \nMust be defined in the CID.');fonction NDfunction varargout = noiseRevCorrND(varargin);s1 = sprintf('glopar{1}{1..D} = size along the D axis\nglopar(2) = signal-to-noise ratio\nglopar(3) the pdf to be chosen (e.g. gauss, unif, sparse) \n');s2 = sprintf('glopar(4) = proportion of active pixel (default = 1)\nglopar(5) = a vector, the filter profile \nMust be defined in the CID.');% ne marche pas pour une grande densité de bullesfunction varargout=noiseLocationND(varargin);	error(sprintf('glopar{1}{1..D} = size along the D axis\nglopar{2} = std of one bubble\nglopar{3} = number of bubbles\nMust be defined in the CID.'));