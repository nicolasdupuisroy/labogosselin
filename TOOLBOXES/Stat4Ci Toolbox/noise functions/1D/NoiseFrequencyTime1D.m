function varargout = NoiseFrequencyTime1D(varargin);global glopar;if ((length(glopar) < 6 | length(glopar) > 8))	s1 = sprintf('glopar{1} = size along the x axis\nglopar(2) = size along the time axis \nglopar(3) = frequency and time std\n');	s2 = sprintf('glopar(4) the pdf to be chosen (e.g. gaussian or uniform)\nglopar(5) proportion of active pixel (default = 1)\nglopar(6) surface under the filter\n');	s3 = sprintf('glopar(7) for padding (reflect, zero and mean)\n glopar(8) bits, min and max \nMust be defined in the CID.\n');	error([s1,s2,s3]);end% global variablexSize = glopar{1};tSize = glopar{2};stdFreq =  glopar{3}(1);stdTime =  glopar{3}(2);noiseFunction = glopar{4}prop =  glopar{5};surface = glopar{6};if size(glopar)<7	padding = 'zero';else	padding = glopar{7};end;% inputoneTrial = varargin{1};% ------------------------------------------------------------------------% -- 1.0 make bubbles% 1.1 set bubble positionsswitch noiseFunctioncase 'gaussian'	randn('state', oneTrial(1));	% prop = sqrt(2) * erfinv(2*(1-prop)-1);	% theNoise(1:xSize/2) = randn(1, xSize/2) .* round(randn(1,xSize/2)-(.5-prop));	for cptTmp = 1 : tSize 		theNoise(cptTmp,1:xSize/2) = randn(1, xSize/2) .* round(rand(1,xSize/2)-(.5-prop));		theNoise(cptTmp,xSize/2+1:xSize) = zeros(1,xSize/2);	end;case 'uniform'	rand('state', oneTrial(1));	for cptTmp = 1 : tSize 		theNoise(cptTmp,1:xSize/2) = rand(1, xSize/2) .* round(rand(1,xSize/2)-(.5-prop));		theNoise(cptTmp,xSize/2+1:xSize) = zeros(1,xSize/2);	end;otherwise	error('the noise generating function is not specified')end;if nargin == 1	varargout{1} = theNoise;	return;end;% 1.2 one bubblestdFreq = stdFreq/sqrt(log(2));	% cut at 0.5stdTime = stdTime/sqrt(log(2));		% cut at 0.5[x, t] = meshgrid(-xSize:xSize-1,-tSize:tSize-1);oneBubble = (1/(2*pi*stdFreq*stdTime))*exp(-( (x/stdFreq).^2 + (t/stdTime).^2)/2);fftOneBubble = fft2(oneBubble);bubblesCenterSym = [fliplr(theNoise),theNoise];bubblesCenterSym = [zeros(tSize/2,2*xSize);bubblesCenterSym;zeros(tSize/2,2*xSize)];bubblesCenterSym = real(ifftshift(ifft2( fft2(bubblesCenterSym) .* fftOneBubble )));% ------------------------------------------------------------------------% -- 2.0 Images preprocessinganImage = varargin{2};% 2.2 image padding paddedImage = ones(1,xSize*2);switch paddingcase 'reflect'	paddedImage = [anImage(end/2:-1:1),anImage,anImage(end:-1:end/2+1)];	case 'mean'	paddedImage = paddedImage * mean(anImage(:));	% la couleur du padding est celle du fond case 'zero'	paddedImage = paddedImage * 0;	% la couleur du padding est egale a 0end;paddedImage(1,xSize/2+1:xSize*3/2) = anImage;% centre l'image avant filtragepaddedImage = paddedImage - mean(paddedImage(:));image_f = fft(paddedImage);% ------------------------------------------------------------------------% -- 2.0 build filter% 2.1  normalizationbubblesCenterSym = bubblesCenterSym / sum(sum(bubblesCenterSym(:,xSize:2*xSize-1))) * surface *	tSize;	cpt = 0;for cptFrames = tSize/2+1 : 3*tSize/2	cpt = cpt + 1;              		randomFilter = bubblesCenterSym(cptFrames,:);		% -- 3.0 filter image	stimuli_f_filt = real(ifft(image_f .* fftshift(randomFilter) )) +.5 ;	stimulus(cpt,:) = stimuli_f_filt(1,xSize /2+1:xSize*6/4);	endmmin = min(stimulus(:));mmax = max(stimulus(:)); % we suppose that (1) images are scaled beetween 0 and 1 and (2) we used 256 gray level, i.e. max bits = 8bits = log2(floor((mmax-mmin)*256));glopar{7}(1) = bits;glopar{7}(2) = mmin;glopar{7}(3) = mmax;varargout{1} = stimulus;