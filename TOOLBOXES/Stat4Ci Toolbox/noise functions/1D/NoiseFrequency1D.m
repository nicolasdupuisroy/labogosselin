function varargout = NoiseFrequency1D(varargin);% ------------------------------------------------------------------------% -- 0.0 global and local variables initializationglobal glopar;if ((length(glopar) < 5 | length(glopar) > 8))	s1 = sprintf('glopar{1} = size along the x axis\nglopar(2) = frequency std\nglopar(3) the pdf to be chosen (e.g. gaussian or uniform)\n');	s2 = sprintf('glopar(4) glopar(4) = proportion of active pixel (default = 1) \nglopar(5) surface under the filter \nglopar(6) optional for padding (reflect, zero and mean) \n');	s3 = sprintf('glopar(7) bits, min and max \nMust be defined in the CID.');	error([s1,s2,s3]);end% global variablexSize = glopar{1};stdFreq = glopar{2};noiseFunction = glopar{3}prop =  glopar{4};surface = glopar{5};if size(glopar)<6	padding = 'zero';else	padding = glopar{6};end;% inputoneTrial = varargin{1};% ------------------------------------------------------------------------% -- 1.0 make bubbles% 1.1 set bubble positionsswitch noiseFunctioncase 'gaussian'	randn('state', oneTrial(1));	theNoise(1:xSize/2) = randn(1, xSize/2) .* round(rand(1,xSize/2)-(.5-prop));case 'uniform'	rand('state', oneTrial(1));	theNoise(1:xSize/2) = rand(1, xSize/2) .* round(rand(1,xSize/2)-(.5-prop));otherwise	error('the noise generating function is not specified')end;theNoise(xSize/2+1:xSize) = zeros(1,xSize/2);varargout{1} = theNoise;if nargin == 1	return;end;% 1.2 one bubblestdFreq = stdFreq/sqrt(log(2));		% cut at 0.5x = [-xSize:xSize-1];oneBubble = (1/(2*pi*stdFreq))*exp(- (x/stdFreq).^2 /2);fftOneBubble = fft(oneBubble);% 1.3 build filterbubblesCenterSym = [fliplr(theNoise),theNoise];randomFilter = real(ifftshift(ifft( fft(bubblesCenterSym) .* fftOneBubble )));% ------------------------------------------------------------------------% -- 2.0 Images preprocessing% 2.1 scale image between 0 and 1anImage = varargin{2};% anImage = ( anImage - min(anImage(:)) ) ./ ( max(anImage(:)) - min(anImage(:)) );% 2.2 image padding paddedImage = ones(1,xSize*2);switch paddingcase 'reflect'	paddedImage = [anImage(end/2:-1:1),anImage,anImage(end:-1:end/2+1)];	case 'mean'	paddedImage = paddedImage * mean(anImage(:));	% la couleur du padding est celle du fond case 'zero'	paddedImage = paddedImage * 0;	% la couleur du padding est egale a 0end;paddedImage(1,xSize/2+1:xSize*3/2) = anImage;% centre l'image avant filtragepaddedImage = paddedImage - mean(paddedImage(:));image_f = fft(paddedImage);% ------------------------------------------------------------------------% 3.0  normalization% randomFilter = randomFilter(xSize+1:end);randomFilter = randomFilter / sum(randomFilter(xSize+1:end)) * surface;	% ------------------------------------------------------------------------% -- 4.0 filter imagestimuli_f_filt = real(ifft(image_f .* fftshift(randomFilter))) +.5 ;stimulus = stimuli_f_filt(1,xSize /2+1:xSize*6/4);	% ------------------------------------------------------------------------% -- 5.0 Output and infornation on the stimulusmmin = min(stimulus(:));mmax = max(stimulus(:)); % we suppose that (1) images are scaled beetween 0 and 1 and (2) we used 256 gray level, i.e. max bits = 8bits = log2(floor((mmax-mmin)*256));glopar{7}(1) = bits;glopar{7}(2) = mmin;glopar{7}(3) = mmax;varargout{1} = stimulus;