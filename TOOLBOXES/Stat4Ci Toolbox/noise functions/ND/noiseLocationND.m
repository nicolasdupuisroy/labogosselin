function varargout=noiseLocationND(varargin);global gloparif (nargin >3)	error('Too many input arguments.')endif (length(glopar)<3 | length(glopar)>4)	error(sprintf('glopar{1}{1..D} = size along the D axis\nglopar{2} = std of one bubble\nglopar{3} = number of bubbles\nMust be defined in the CID.\nglopar{4} = information about the stimulus: bits, min and max\n'));endoneTrial = varargin{1};rand('state', oneTrial(1));dimNumber =  max(size(glopar{1}));N = prod(glopar{1});stdev = glopar{2};nBubbles = glopar{3}switch dimNumbercase 1	theNoise = zeros(1,glopar{1});		x1 = [-glopar{1}/2:glopar{1}/2-1];	maBulle = exp(-.5*(x1.^2/stdev^2 ));case 2	theNoise = zeros(glopar{1});	[x1,x2] = meshgrid(-glopar{1}(1)/2:glopar{1}(1)/2-1,-glopar{1}(2)/2:glopar{1}(2)/2-1); 	maBulle = exp(-.5*(x1.^2/(glopar{2}(1))^2 + x2.^2/(glopar{2}(2))^2 ));case 3	theNoise = zeros(glopar{1});	[x1,x2,x3] = meshgrid(-glopar{1}(1)/2:glopar{1}(1)/2-1,-glopar{1}(2)/2:glopar{1}(2)/2-1,-glopar{1}(3)/2:glopar{1}(3)/2-1); 	maBulle = exp(-.5*(x1.^2/(glopar{2}(1))^2 + x2.^2/(glopar{2}(2))^2 + x3.^2/(glopar{2}(3))^2));case 4	theNoise = zeros(glopar{1});	[x1,x2,x3,x4] = meshgrid(-glopar{1}(1)/2:glopar{1}(1)/2-1,-glopar{1}(2)/2:glopar{1}(2)/2-1,-glopar{1}(3)/2:glopar{1}(3)/2-1,-glopar{1}(4)/2:glopar{1}(4)/2-1); 	maBulle = exp(-.5*(x1.^2/(glopar{2}(1))^2 + x2.^2/(glopar{2}(2))^2 + x3.^2/(glopar{2}(3))^2 + x4.^2/(glopar{2}(4))^2));case 5	theNoise = zeros(glopar{1});	[x1,x2,x3,x4,x5] = meshgrid(-glopar{1}(1)/2:glopar{1}(1)/2-1,-glopar{1}(2)/2:glopar{1}(2)/2-1,-glopar{1}(3)/2:glopar{1}(3)/2-1,-glopar{1}(4)/2:glopar{1}(4)/2-1,-glopar{1}(5)/2:glopar{1}(5)/2-1);	maBulle = exp(-.5*(x1.^2/(glopar{2}(1))^2 + x2.^2/(glopar{2}(2))^2 + x3.^2/(glopar{2}(3))^2 + x4.^2/(glopar{2}(4))^2 + x4.^2/(glopar{2}(5))^2));otherwise	error('locationNoiseND not implemented for more than 5 dimensions. Please, send me the programm if you do it')end;ind = ceil(rand(1,nBubbles)*N);uind  = unique(ind);theNoise(uind) = hist(ind,uind);if (nargin == 1)	varargout{1} = theNoise;	returnend;anImage = varargin{2};anImage = (anImage - min(anImage(:))) / (max(anImage(:)) - min(anImage(:)));theNoise = real(ifftn(fftn(theNoise) .* fftn(maBulle) ));theStimulus = theNoise.*(anImage-0.5)+.5;mmin = min(theStimulus(:));mmax = max(theStimulus(:)); % we suppose that (1) images are scaled beetween 0 and 1 and (2) we used 256 gray level, i.e. max bits = 8bits = log2(floor((mmax-mmin)*256));glopar{4}(1) = bits;glopar{4}(2) = mmin;glopar{4}(3) = mmax;varargout{1} = theStimulus;