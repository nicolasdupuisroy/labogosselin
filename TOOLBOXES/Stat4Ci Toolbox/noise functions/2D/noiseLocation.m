function varargout=noiseLocation(varargin)global gloparif (nargin >2)	error('Too many input arguments.')endlength(glopar)if (length(glopar)~=2 & length(glopar)~=3)	s1 = sprintf('glopar{1} = size along the X AND Y axis\nglopar{2} = std of one bubble\n');	s2 = sprintf('Must be defined in the CID.\nglopar{3} = information about the stimulus: bits, min and max\n');	error([s1,s2]);	endoneTrial = varargin{1};rand('state', oneTrial(1));xSize = glopar{1}(1);ySize = glopar{1}(2);theNoise = zeros(ySize, xSize);tempRand = rand(ySize, xSize);for jj = 1:oneTrial(2),	[scrap xMax]=max(max(tempRand));	[scrap yMax]=max(tempRand(:,xMax));	theNoise(yMax,xMax)=theNoise(yMax,xMax)+1;	tempRand(yMax,xMax)=0;endif (nargin == 1)	varargout{1} = theNoise;	returnend;anImage = varargin{2};stdev = glopar{2};nZero = 3;maxHalfSize = round(stdev * nZero);gauss = zeros(2*maxHalfSize,2*maxHalfSize);[y,x] = meshgrid(-maxHalfSize:maxHalfSize,-maxHalfSize:maxHalfSize);gauss = exp(-(x.^2/stdev^2)-(y.^2/stdev^2));gauss = gauss/max(gauss(:));clear x, y;winPlane = zeros(ySize,xSize);stimulus = zeros(ySize,xSize);tempPlane = zeros(ySize+maxHalfSize-1,xSize+maxHalfSize-1);tempPlane = real(ifft2(fft2(gauss,ySize+maxHalfSize-1,xSize+maxHalfSize-1).*fft2(theNoise, ySize+maxHalfSize-1, xSize+maxHalfSize-1)));winPlane = min(tempPlane(maxHalfSize:ySize+maxHalfSize-1,maxHalfSize:xSize+maxHalfSize-1), 1);stimulus = uint8(round(winPlane.*(double(anImage)-128))+128);% mmin = min(stimulus(:))/256;% mmax = max(stimulus(:))/256; % we suppose that (1) images are scaled beetween 0 and 256 and (2) we used 256 gray level, i.e. max bits = 8% bits = log2(floor((mmax-mmin)*256));% glopar{4}(1) = bits;% glopar{4}(2) = mmin;% glopar{4}(3) = mmax;varargout{1} = stimulus;