function output = NoiseFrequencyFred(varargin);global glopar;if (length(glopar) ~= 4)	s1 = sprintf('glopar{1}[x, y] = size along the x and y axis\nglopar{2} = std_frequency\nglopar(3) ''empty'' or ''randomPhase''\n');	s2 = printf('glopar{4} for padding (''reflect'', ''repeat'', or ''a_constant'' such as ''mean(anImage(:))'' or ''1'')\nMust be defined in the CID.\n');	error([s1,s2]);endxSize = glopar{1}(1);ySize = glopar{1}(2);stdFreq = glopar{2};addNoise = glopar{3};padding = glopar{4};oneTrial = varargin{1};rand('state', oneTrial(1));theNoise(1,1:xSize) = round(rand(1,xSize)-(.5-oneTrial(2))); % LSF on the leftif nargin == 1	output = theNoise;	return;end;x = [-xSize:xSize-1];oneBubble = 1/(sqrt(2*pi)*stdFreq^2)*exp(-1/(2*stdFreq^2)*x.^2);oneBubble = oneBubble / max(oneBubble(:));% % % % % % % % % % % % % For testing purposes% % % % % % % % % % % % % theNoise = zeros(1, xSize);% cpf = 8;% k = 3/2; % if a face occupies 2/3 of a small image, which is usually the case% c = 2; % here, the padded image is twice the original image% cpi = cpf * k;% cpI = cpi * c;% theNoise(round(cpI)) = 1;% % % % % % % % % % % % % % % % % % % % % % % % bubblesCenterSym = [fliplr(theNoise), theNoise]; % LSF in centerbubblesCenterSym = min(conv2(bubblesCenterSym, oneBubble, 'same'), 1);  % LSF in center% figure, plot(bubblesCenterSym)anImage = varargin{2};paddedImage = ones(xSize*2,ySize*2);switch paddingcase 'reflect'	paddedImage(1:xSize/2,1:xSize/2) = fliplr(flipud(anImage(1:xSize/2,1:xSize/2)));	paddedImage(xSize/2+1:3*xSize/2,1:xSize/2) = fliplr(anImage(:,1:xSize/2));	paddedImage(3*xSize/2+1:2*xSize,1:xSize/2) = fliplr(flipud(anImage(xSize/2+1:xSize,1:xSize/2)));	paddedImage(1:xSize/2,3*xSize/2+1:2*xSize) = fliplr(flipud(anImage(1:xSize/2,xSize/2+1:xSize)));	paddedImage(xSize/2+1:3*xSize/2,3*xSize/2+1:2*xSize) = fliplr(anImage(:,xSize/2+1:xSize));	paddedImage(3*xSize/2+1:2*xSize,3*xSize/2+1:2*xSize) = fliplr(flipud(anImage(xSize/2+1:xSize,xSize/2+1:xSize)));	paddedImage(1:xSize/2,xSize/2+1:3*xSize/2) = flipud(anImage(1:xSize/2,:));	paddedImage(3*xSize/2+1:2*xSize,xSize/2+1:3*xSize/2) = flipud(anImage(xSize/2+1:xSize,:));case 'repeat'	paddedImage(1:xSize/2,1:xSize/2) = anImage(xSize/2+1:xSize,xSize/2+1:xSize);	paddedImage(xSize/2+1:3*xSize/2,1:xSize/2) = anImage(:,xSize/2+1:xSize);	paddedImage(3*xSize/2+1:2*xSize,1:xSize/2) = anImage(1:xSize/2,xSize/2+1:xSize);	paddedImage(1:xSize/2,3*xSize/2+1:2*xSize) = anImage(xSize/2+1:xSize,1:xSize/2);	paddedImage(xSize/2+1:3*xSize/2,3*xSize/2+1:2*xSize) = anImage(:,1:xSize/2);	paddedImage(3*xSize/2+1:2*xSize,3*xSize/2+1:2*xSize) = anImage(1:xSize/2,1:xSize/2);	paddedImage(1:xSize/2,xSize/2+1:3*xSize/2) = anImage(xSize/2+1:xSize,:);	paddedImage(3*xSize/2+1:2*xSize,xSize/2+1:3*xSize/2) = anImage(1:xSize/2,:);otherwise	paddedImage = paddedImage * eval(padding); end;paddedImage(xSize/2+1:xSize*3/2,ySize/2+1:ySize*3/2) = anImage;meanImage = mean(paddedImage(:));paddedImage = paddedImage - meanImage;image_f = fft2(paddedImage); % LSF in periphery[x, y] = meshgrid(-xSize:xSize-1,-xSize:xSize-1);rayon = sqrt(x .^2 + y .^2);rayon((rayon > (xSize))) = xSize+1;rayon = max(rayon,1);profileFred = [bubblesCenterSym(xSize+1:2*xSize), 0]; % LSF on the leftprofil2D = min(max(profileFred(round(rayon)), 0), 1); % LSF in centerprofil2D = fftshift(max(min(profil2D, 1), 0)); % LSF in peripheryswitch addNoisecase 'empty'	stimuli_f_filt = real(ifft2(image_f .* profil2D)) + meanImage;case 'randomPhase'	if nargin >= 3,		magnIm = varargin{3};	else		[thetaIm, magnIm] = cart2pol(real(image_f), imag(image_f));	end;	temp = rand(size(profil2D)) - .5;	Fs_temp = fft2(temp);	[thetaTemp, magnTemp] = cart2pol(real(Fs_temp), imag(Fs_temp));	[XX, YY] = pol2cart(thetaTemp, magnIm);	fNoise = XX + YY * i;	stimuli_f_filt = real(ifft2(image_f .* profil2D + fNoise .* (1-profil2D))) + meanImage;otherwise	error('Option not available.')end;output = stimuli_f_filt(xSize/2+1:xSize*3/2, xSize/2+1:xSize*3/2);